<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBF vs SR — Beat-Matching with Observer</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#151e29; --panel-2:#1a2532;
    --ink:#eaf2ff; --muted:#a9bed6; --accent:#4aa8ff; --hot:#ff6b6b;
    --good:#5cf2a5; --warn:#ffd76b;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  h1{margin:14px 0 6px;text-align:center;font-size:20px}
  .desc{max-width:980px;margin:0 auto 12px;color:var(--muted);text-align:center}
  .wrap{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:320px 1fr;gap:12px}
  .panel{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid #1f2b39;border-radius:12px;padding:12px}
  .controls .group{border:1px solid #243244;border-radius:10px;padding:10px;margin-bottom:10px;background:#0f1620}
  .row{display:flex;gap:10px;align-items:center;margin:6px 0;flex-wrap:wrap}
  label{min-width:150px;color:#cfe0f7}
  input[type="range"]{width:160px}
  .radio-row{display:flex;gap:12px;flex-wrap:wrap}
  .btn{padding:8px 12px;border:2px solid var(--accent);background:#0d1622;color:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:var(--accent);color:#000}
  canvas{width:100%;height:auto;background:#000;border:2px solid #1b2635;border-radius:12px;box-shadow:0 0 18px rgba(74,168,255,0.15)}
  .legend{margin-top:8px;color:#cfe0f7}
  .cards{display:grid;gap:8px}
  .card{border:1px solid #223044;border-radius:10px;padding:8px;background:#0e1520}
  .card h3{margin:0 0 4px;font-size:14px;color:#d8e8ff}
  .kv{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#102031;border:1px solid #27445f;color:#a9c8e6;font-size:12px}
  .pill.good{background:#0b2a1e;border-color:#1f7a4a;color:#bcffde}
  .pill.warn{background:#2a230b;border-color:#7a6a1f;color:#ffefbd}
</style>
</head>
<body>
  <h1>CBF vs SR — Beat-Matching with Observer</h1>
  <p class="desc">
    Beat events occur when the particle’s phase aligns with the observer’s within a tolerance. Toggle clock rules to compare
    CBF’s directional pacing and SR’s symmetric dilation. Cards show predicted vs measured beat periods plus γ(w).
  </p>

  <div class="wrap">
    <div class="panel controls">
      <div class="group">
        <div class="row">
          <label>Observer speed (v<sub>obs</sub>)</label>
          <input type="range" id="vObs" min="0" max="0.99" step="0.01" value="0.30">
          <span class="kv" id="vObsOut">0.30c</span>
        </div>
        <div class="row">
          <label>Observer base frequency f<sub>obs</sub></label>
          <input type="range" id="fObs" min="0.2" max="5" step="0.1" value="2.0">
          <span class="kv" id="fObsOut">2.0 Hz</span>
        </div>
        <div class="row">
          <label>Beat tolerance (phase)</label>
          <input type="range" id="tol" min="0.02" max="0.50" step="0.02" value="0.12">
          <span class="kv" id="tolOut">±0.12 rad</span>
        </div>
        <div class="row">
          <label>Scene speed (px/s)</label>
          <input type="range" id="sceneSpd" min="80" max="900" step="20" value="420">
          <span class="kv" id="sceneSpdOut">420</span>
        </div>
        <div class="row radio-row">
          <label>Clock rule</label>
          <label><input type="radio" name="rule" id="ruleCBF" checked> CBF (directional)</label>
          <label><input type="radio" name="rule" id="ruleSR"> SR (symmetric)</label>
        </div>
      </div>

      <div class="group">
        <div class="row">
          <label>New particle speed</label>
          <input type="range" id="vNew" min="0" max="0.99" step="0.01" value="0.60">
          <span class="kv" id="vNewOut">0.60c</span>
        </div>
        <div class="row">
          <label>Particle rest frequency f<sub>0</sub></label>
          <input type="range" id="fNew" min="0.2" max="5" step="0.1" value="2.0">
          <span class="kv" id="fNewOut">2.0 Hz</span>
        </div>
        <div class="row">
          <button class="btn" id="addOne">Add Particle</button>
          <button class="btn" id="add5">+5 Random</button>
          <button class="btn" id="clear">Clear</button>
        </div>
      </div>

      <div class="group">
        <div class="row"><span class="pill">Bright = faster clock</span> <span class="pill good">Beat match</span> <span class="pill warn">Pred ≠ Meas</span></div>
        <div class="legend" id="legend"></div>
      </div>
    </div>

    <div class="panel">
      <canvas id="cv" width="900" height="580"></canvas>
      <div class="cards" id="cards"></div>
    </div>
  </div>

<script>
const TWO_PI = Math.PI*2;
function wrapToPi(a){ // (-π, π]
  let x = (a + Math.PI) % TWO_PI;
  if (x < 0) x += TWO_PI;
  return x - Math.PI;
}

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const vObs = document.getElementById('vObs');
const vObsOut = document.getElementById('vObsOut');
const fObs = document.getElementById('fObs');
const fObsOut = document.getElementById('fObsOut');
const tol = document.getElementById('tol');
const tolOut = document.getElementById('tolOut');
const sceneSpd = document.getElementById('sceneSpd');
const sceneSpdOut = document.getElementById('sceneSpdOut');

const ruleCBF = document.getElementById('ruleCBF');
const ruleSR  = document.getElementById('ruleSR');

const vNew = document.getElementById('vNew');
const vNewOut = document.getElementById('vNewOut');
const fNew = document.getElementById('fNew');
const fNewOut = document.getElementById('fNewOut');

const addOne = document.getElementById('addOne');
const add5   = document.getElementById('add5');
const clearBtn = document.getElementById('clear');

const legend = document.getElementById('legend');
const cards  = document.getElementById('cards');

function gamma(v){ return 1/Math.sqrt(1 - v*v); }
function relVel(vp, vo){ // Einstein addition
  const w = (vp - vo) / (1 - vp*vo);
  return Math.max(-0.999, Math.min(0.999, w));
}

function rateCBF(vp, vo){
  // CBF directional clock rate wrt observer: 1 + (vo - vp), floored at small positive
  return Math.max(0.01, 1 + (vo - vp));
}
function rateSR(vp, vo){
  // SR symmetric: dτ/dt = sqrt(1 - w^2)
  const w = relVel(vp, vo);
  return Math.sqrt(Math.max(0.0, 1 - w*w));
}

class Particle {
  constructor(x, y, v, f0){
    this.x=x; this.y=y; this.v=v; this.f0=f0;

    // absolute phase for drawing
    this.phase = Math.random()*TWO_PI;

    // unwrapped relative phase (particle - observer) for beat logic
    this.relPhase = 0;
    this.relPrev  = 0;

    this.h = Math.floor(Math.random()*360);
    this.tau = 0; this.age = 0;

    this.lastBeatT = null;
    this.beatSamples = [];
    this.flash = 0;

    this.kPrev = 0;        // previous integer turn count of relPhase / (2π)
    this.lastCrossT = null; // last exact crossing time (phase ≡ 0 mod 2π)    
    
    // gating    
    this.armed = true;
    this.deadband = 0.08;     // near-zero band (rad)
    this.refracUntil = 0;     // refractory end time
  }
  effRate(){ return ruleSR.checked ? rateSR(this.v, sim.vObs) : rateCBF(this.v, sim.vObs); }
  effFreq(){ return this.f0 * this.effRate(); }

  _predBeatAndRefrac(){
    const df = Math.abs(this.effFreq() - sim.fObs);
    const Tpred = (df > 1e-6) ? 1/df : Infinity;
    const refrac = isFinite(Tpred) ? Math.max(0.04, 0.5*Tpred) : 0.25;
    return {Tpred, refrac};
  }

  step(dt){
    const w = relVel(this.v, sim.vObs);
    this.x += w * sim.pxPerSec * dt;

    const r = this.effRate();
    this.tau += dt * r;
    this.age += dt;
    this.phase += TWO_PI*this.f0*r*dt;

    // unwrapped relative phase evolution
    const dphi = TWO_PI * (this.effFreq() - sim.fObs) * dt;
    this.relPrev = this.relPhase;
    this.relPhase += dphi;

// === Robust beat detection via integer turn counting with interpolation ===
// Count how many multiples of 2π we crossed since last frame.
const kNow = Math.floor(this.relPhase / TWO_PI);
const dk = kNow - this.kPrev;

if (dk !== 0) {
  // constant angular speed over this frame (good for our integrator)
  const omega = TWO_PI * (this.effFreq() - sim.fObs); // d(relPhase)/dt
  if (Math.abs(omega) > 1e-9) {
    // direction (+/- 1) and how many crossings to process
    const stepSign = dk > 0 ? 1 : -1;
    let k = this.kPrev;

    // Process each missed crossing in order, estimating its exact time
    for (let n = 0; n !== dk; n += stepSign) {
      const kCross = k + stepSign;          // the next integer to reach
      const phiCross = TWO_PI * kCross;     // target phase
      // linear backtrack within this frame to find crossing time
      // relPhase_now = relPhase_prev + omega*dt  ⇒  t_cross = now - (relPhase_now - phiCross)/omega
      const now = sim.t;
      const tCross = now - (this.relPhase - phiCross) / omega;

      if (this.lastCrossT !== null) {
        const interval = tCross - this.lastCrossT;
        if (interval > 0) {
          this.beatSamples.push(interval);
          if (this.beatSamples.length > 8) this.beatSamples.shift();
        }
      }
      this.lastCrossT = tCross;
      this.flash = 0.25; // visual ping for the latest crossing

      k = kCross; // move to next
    }
  }

  // store the new integer turn count
  this.kPrev = kNow;
}

  }

  draw(){
    const r = 8 + 4*Math.sin(this.phase);
    const rate = this.effRate();
    const intensity = Math.min(100, 40 + rate*60);
    ctx.fillStyle = `hsl(${this.h} 80% ${intensity}%)`;
    ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = `hsl(${this.h} 70% 50% / 0.6)`; ctx.lineWidth = 2; ctx.stroke();

    // velocity arrow
    ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2 + this.v*2;
    ctx.beginPath(); ctx.moveTo(this.x-14,this.y); ctx.lineTo(this.x+26+this.v*28,this.y); ctx.stroke();

    if (this.flash>0){
      ctx.strokeStyle = 'rgba(92,242,165,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(this.x, this.y, r+8+12*(0.25-this.flash)*3, 0, Math.PI*2); ctx.stroke();
    }
  }

  stats(){
    const w = relVel(this.v, sim.vObs);
    const g = gamma(Math.abs(w));
    const r = this.effRate();
    const fe = this.f0 * r;
    const df = Math.abs(fe - sim.fObs);
    const Tpred = df>1e-6 ? 1/df : Infinity;
    const Tmeas = this.beatSamples.length
      ? this.beatSamples.reduce((a,b)=>a+b,0)/this.beatSamples.length
      : NaN;
    return { w, g, r, fe, df, Tpred, Tmeas };
  }
}

const sim = {
  vObs: parseFloat(vObs.value),
  fObs: parseFloat(fObs.value),
  tol:  parseFloat(tol.value),
  t:0,
  obsPhase:0,
  pxPerSec: parseFloat(sceneSpd.value),
  gridOffset:0,
  gridSpacing:50,
  particles:[]
};

function addParticle(x, y, v, f0){
  const p = new Particle(x,y,v,f0);
  p.relPhase = p.phase - sim.obsPhase; // initialize from current absolute phases
  p.kPrev = Math.floor(p.relPhase / TWO_PI);
  p.lastCrossT = null;  
  p.relPrev  = p.relPhase;
  const { Tpred } = p._predBeatAndRefrac();
  p.refracUntil = isFinite(Tpred) ? (sim.t + Math.max(0.03, 0.25*Tpred)) : sim.t + 0.2;
  sim.particles.push(p);
}

function addRandom(n){
  for(let i=0;i<n;i++){
    const y = 140 + Math.random()*(cv.height-220);
    const x = cv.width*0.5 + (Math.random()*2-1)*cv.width*0.25;
    const v = Math.max(0, Math.min(0.99, parseFloat(vNew.value) + (Math.random()*0.4 - 0.2)));
    const f0 = Math.max(0.2, parseFloat(fNew.value) + (Math.random()*0.8 - 0.4));
    addParticle(x,y,v,f0);
  }
}

function drawGrid(dt){
  const gridSpeed = sim.vObs * sim.pxPerSec;
  sim.gridOffset -= gridSpeed * dt;
  if (sim.gridOffset <= -sim.gridSpacing) sim.gridOffset += sim.gridSpacing;
  ctx.save();
  ctx.strokeStyle = 'rgba(100,150,255,0.12)';
  ctx.lineWidth=1;
  for(let x=sim.gridOffset;x<cv.width+sim.gridSpacing;x+=sim.gridSpacing){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke();
  }
  for(let y=0;y<cv.height+sim.gridSpacing;y+=sim.gridSpacing){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke();
  }
  ctx.restore();
}

function frame(ts){
  requestAnimationFrame(frame);
  const dt = Math.min(0.05, (ts-(frame._last||ts))/1000);
  frame._last = ts;
  sim.t += dt;

  // observer oscillator
  sim.obsPhase += TWO_PI*sim.fObs*dt;

  // clear + grid
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,cv.width,cv.height);
  drawGrid(dt);

  // step/draw
  sim.particles.forEach(p=>p.step(dt));
  sim.particles.forEach(p=>p.draw());
  sim.particles = sim.particles.filter(p=>p.x>-60 && p.x<cv.width+60);

  // HUD: observer oscillator
  const cx = cv.width*0.5, cy = 60, R=28;
  ctx.strokeStyle = '#a8d1ff'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.stroke();
  ctx.fillStyle = '#a8d1ff';
  ctx.beginPath(); ctx.arc(cx + Math.cos(sim.obsPhase)*R, cy + Math.sin(sim.obsPhase)*R, 5, 0, Math.PI*2); ctx.fill();
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillStyle='#cfe0f7';
  ctx.textAlign='center';
  ctx.fillText(`Observer oscillator  f_obs=${sim.fObs.toFixed(2)} Hz   v_obs=${sim.vObs.toFixed(2)}c`, cx, cy+46);

  updateLegend();
  renderCards();
}

function updateLegend(){
  const txt = (ruleSR.checked
    ? `SR clock: dτ/dt = √(1−w²), w=(v_p−v_obs)/(1−v_p v_obs)`
    : `CBF clock: dτ/dt = 1 + (v_obs − v_p)  (floored at 0.01)`);
  legend.innerHTML = `<div>${txt}</div>
    <div>Beat period prediction: T = 1 / | f_eff − f_obs |, counted via wrapped-phase zero-crossings with hysteresis & refractory.</div>`;
}

function renderCards(){
  cards.innerHTML = '';
  sim.particles.slice(0,6).forEach((p,idx)=>{
    const s = p.stats();
    const predOK = Number.isFinite(s.Tpred);
    const measOK = Number.isFinite(s.Tmeas);
    const off = (predOK && measOK) ? Math.abs(s.Tpred - s.Tmeas)/s.Tpred : NaN;

    const cls = (!isNaN(off) && off<0.15) ? 'pill good' : (isNaN(off) ? 'pill' : 'pill warn');
    const errPct = (!isNaN(off) ? (off*100).toFixed(1) : null);
    const matchPct = (!isNaN(off) ? (100 - off*100).toFixed(1) : null);
    const badge = isNaN(off) ? 'collecting…'
                 : (cls==='pill good' ? `match ${matchPct}%` : `error ${errPct}%`);

    const html = `
      <div class="card">
        <h3>Particle #${idx+1}  <span class="${cls}">${badge}</span></h3>
        <div class="kv">
          v_p=${p.v.toFixed(2)}c, w=${s.w.toFixed(2)}c, γ(w)=${s.g.toFixed(3)}<br/>
          f0=${p.f0.toFixed(2)} Hz,  f_eff=${s.fe.toFixed(3)} Hz<br/>
          |Δf|=${s.df.toFixed(3)} Hz,  T_pred=${predOK? s.Tpred.toFixed(3)+' s':'∞'}<br/>
          T_meas=${measOK? s.Tmeas.toFixed(3)+' s':'—'}
        </div>
      </div>`;
    const div = document.createElement('div');
    div.className='card';
    div.innerHTML = html;
    div.innerHTML = div.querySelector('.card') ? div.querySelector('.card').innerHTML : html;
    cards.appendChild(div);
  });
}

// UI wiring
function syncOut(){
  vObsOut.textContent = `${parseFloat(vObs.value).toFixed(2)}c`;
  fObsOut.textContent = `${parseFloat(fObs.value).toFixed(1)} Hz`;
  tolOut.textContent  = `±${parseFloat(tol.value).toFixed(2)} rad`;
  vNewOut.textContent = `${parseFloat(vNew.value).toFixed(2)}c`;
  fNewOut.textContent = `${parseFloat(fNew.value).toFixed(1)} Hz`;
  sceneSpdOut.textContent = `${sim.pxPerSec.toFixed(0)}`;
}
vObs.addEventListener('input', ()=>{ sim.vObs=parseFloat(vObs.value); syncOut(); });
fObs.addEventListener('input', ()=>{ sim.fObs=parseFloat(fObs.value); syncOut(); });
tol.addEventListener('input', ()=>{ /* tolerance used in beat draw only */ syncOut(); });
sceneSpd.addEventListener('input', ()=>{ sim.pxPerSec=parseFloat(sceneSpd.value); syncOut(); });

vNew.addEventListener('input', syncOut);
fNew.addEventListener('input', syncOut);

addOne.addEventListener('click', ()=>{
  addParticle(cv.width*0.5, 320, parseFloat(vNew.value), parseFloat(fNew.value));
});
add5.addEventListener('click', ()=>addRandom(5));
clearBtn.addEventListener('click', ()=>{ sim.particles.length=0; });

cv.addEventListener('click', (e)=>{
  const r = cv.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;
  addParticle(x, y, parseFloat(vNew.value), parseFloat(fNew.value));
});

// seed
addParticle(cv.width*0.5 - 160, 220, 0.10, 2.0);
addParticle(cv.width*0.5,       320, 0.60, 2.0);
addParticle(cv.width*0.5 + 160, 420, 0.90, 2.0);

syncOut();
requestAnimationFrame(frame);
</script>
</body>
</html>
